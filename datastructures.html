<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<title> Data Structures </title>
	<link rel="stylesheet" type="text/css" href="dataStructures.css">

	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

	<link href="https://fonts.googleapis.com/css?family=Bree+Serif|Cinzel:400,700|Raleway" rel="stylesheet">

	<link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">


	<script src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
</head>

<body>

<nav class="navbar navbar-expand-lg navbar-light bg-light">
	<a class="navbar-brand" href="#">C++ Reference</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
	</button>
	<div class="collapse navbar-collapse" id="navbarNavDropdown">
		<ul class="navbar-nav">
			<!-- <li class="nav-item active">
				<a class="nav-link" href="#dataTypes">Data Types <span class="sr-only">(current)</span></a>
			</li> -->
			<li class="nav-item">
				<a class="nav-link" href="#dataTypes">Data Types <span class="sr-only">(current)</span></a>
			</li>
			<li class="nav-item">
				<a class="nav-link" href="#dataContainers">Data Containers</a>
			</li>
			<!-- <li class="nav-item">
				<a class="nav-link" href="#">Pricing</a>
			</li>
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
				Dropdown link
				</a>
				<div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
					<a class="dropdown-item" href="#">Action</a>
					<a class="dropdown-item" href="#">Another action</a>
					<a class="dropdown-item" href="#">Something else here</a>
				</div>
			</li> -->
		</ul>
	</div>
</nav>

<div class='container my-5'>

	


	<!-- <div class='pageTitle my-1'> Data Types and Structures </div> -->


	<div class='d-block fontLevel3 my-1' id='dataTypes'> Data Types</div>

	<div class='d-block fontLevel2 my-1' id='primitiveDataTypes'> Primitive Data Types</div>
	<div class=' d-block fontLevel0'>
			Fundamental or primitive data types in C++ are: integers, floating point numbers and void. <br>
			Integral types handle whole numbers, floating point numbers handle fractional numbers.
			Voids can not be used to declare a variable type. Instead, they are used to define a function that does not return any variable.

		<span class=' d-block my-3'> </span>


		<table>
			<thead>
				<tr>
					<td>Category</td>
					<td>Type</td>
					<td>Content</td>
				</tr>
				<tr>
					<td class="noBorderDown">Integral</td>
					<td>char (Character)</td>
					<td>These are used for storing characters. This uses 1 byte (i.e 2<sup>8*1</sup>) of memory.</td>
				</tr>
				<tr>
					<td class="noBorderDown noBorderTop"></td>
					<td>wchar_t (Wide Character)</td>
					<td>These are characters that occupy slightly more space than char. These occupy 2-4 bytes (i.e 2<sup>8*2</sup> to 2<sup>8*4</sup>) of memory.</td>
				</tr>
				<tr>
					<td class="noBorderDown noBorderTop"></td>
					<td>int (Integer)</td>
					<td>These occupy 4 bytes (i.e 2<sup>8*4</sup>) of memory.</td>
				</tr>
				<tr>
					<td class="noBorderDown noBorderTop"></td>
					<td>bool (Boolean)</td>
					<td>These occupy 2 bits (i.e 0 or 1) of memory.</td>
				</tr>
				<tr>
					<td class="noBorderDown">Floating Point Numbers</td>
					<td>float (Float)</td>
					<td>These occupy 4 bytes (i.e 2<sup>8*4</sup>) of memory.</td>
				</tr>
				<tr>
					<td class="noBorderDown noBorderTop"></td>
					<td>double (Double Floating point)</td>
					<td>These occupy 8 bytes (i.e 2<sup>8*8</sup>) of memory.</td>
				</tr>

				<tr>
					<td class="noBorderDown">Modifiers</td>
					<td>long, short</td>
					<td>These are used to modify the length of an integer or in the case of long, a double. <br>
						short int occupies 2 bytes (i.e 2<sup>8*2</sup>);<br> 
						long int occupies 4 bytes (i.e 2<sup>8*4</sup>); <br> 
						long long int occupies 8 bytes (i.e 2<sup>8*8</sup>);<br>
						long double occupies 8 or 12 bytes (i.e 2<sup>8*8</sup> or 2<sup>8*12</sup>) of memory </td>
				</tr>
				<tr>
					<td class="noBorderTop"></td>
					<td>signed and unsigned.</td>
					<td>These specify if negative numbers are accommodated in the definition of a data type. <br>Eg: unsigned int occupy the range of 0 to 2<sup>8*4</sup>-1; <br> signed int occupy the range 2<sup>8*4-1</sup> to 2<sup>8*4-1</sup>-1</td>
				</tr>
			</thead>
		</table>

	</div>

	<span class=' d-block my-3'> </span>
	<div class='d-block fontLevel2 my-1' id='primitiveDataTypes'> Composite Data Types</div>
	<div class=' d-block fontLevel0'>
		Composite data types in C++ data types that can be derived or constructed from the primitive data types. Examples of composite data types are: 
		<ul>
			<li>String
				<ul><li>sequence of characters that is terminated by \0, the null character. Thus, string are null terminated sequence of characters</li></ul>
			</li>
			<li>Arrays
				<ul><li>series of elements of the same primitive data type that are stored in contiguous (adjacent) memory locations. An identifier is the unique name given to the defined data type. In int a = 7; a is the unique identifier given to this data of type int. Arrays are defined as such:<br> int foo [5] = {}; <br>int foo[ ] = {3, 1, 2,};<br> int foo[ ]{3,1,2};<br> int foo[2]={1,2}</li></ul>
			</li>
			<li>Pointers
				<ul><li> </li></ul>
			</li>
			<li>Dynamic Memory
				<ul><li></li></ul>
			</li>
			<li>Data structures
				<ul><li></li></ul>
			</li>
		</ul>


		<span class=' d-block my-3'> </span>
	</div>


	<span class=' d-block my-5'> </span>

	<div class='d-block fontLevel3 my-1' id='dataContainers'> Data Containers</div>
	The types of data containers in c++ are:
	<ul>
		<li>Sequence containers
			<ul><li>array, vector, deque, forward_list, list</li></ul>
		</li>
		<li>Container Adaptors
			<ul><li>stack, queue, priority_queue</li></ul>
		</li>
		<li>Associative Containers
			<ul><li>Set, Multiset, Map, Multimap</li></ul>
		</li>
		<li> Unordered Associative Containers
			<ul><li>unordered_set, unordered_multiset, unordered_map, unordered_multimap</li></ul>
		</li>
	</ul>
	


	<span class=' d-block my-5'> </span>
	<div class='d-block fontLevel2 my-1' id=''> Sequence Containers</div>

	<div class='d-block fontLevel1 mt-1' id=''> Arrays</div>
	<div class=' d-block fontLevel0'>
		Arrays are fixed-sized sequence containers. This means that they occupy adjacent locations in memory. They hold a specific number of elements in a linear sequence. Internally, arrays do not store anything other than the elements that it contains. An array does not even know its size. They have 3 important properties. 

		<ol>
			<li>Data is stored in a linear sequence</li>
			<li>Data is stored in contiguous (adjacent) space in memory</li>
			<li>Container has a fixed size. They cannot be contracted or expanded</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>


	<div class='d-block fontLevel1 mt-1' id=''> Vectors</div>
	<div class=' d-block fontLevel0'>
		Vectors are essentially arrays that permit dynamic allocation of the size. They are stored linearly in memories so other elements can be accessed using offsets of pointers to its elements, similar to arrays. 
		<span class=' d-block my-1'> </span>
		When vector needs to expand, it may entail reallocating another chunk of memory and transferring all the data from the current space to another space. This implies that growing vectors may be an expensive task in terms of processing time. Since this reallocation of space is expensive, vectors generally have a capacity that is greater than its current size at the point of allocation, to prevent the need for too frequent reallocation. This means that the capacity of the vector is not guaranteed to be the same as the number of elements it contains. 
		<span class=' d-block my-1'> </span>
		Compared to arrays, vectors consume more memory to allow for its dynamic allocation of data. Compared to list, deques, and forward_list, vectors are efficient at accessing data. However, they are only efficient at adding or removing data from its end.

		<span class=' d-block my-1'> </span>
		<ol>
			<li>Data is stored in a linear sequence</li>
			<li>Data is stored in contiguous (adjacent) space in memory</li>
			<li>Container has dynamic size. They can be contracted or expanded</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>
			
	<div class='d-block fontLevel1 mt-1' id=''> Deque</div>
	<div class=' d-block fontLevel0'>
		Deque (pronounced deck) are double-ended queues. Deques are sequenced containers that can be expanded or contracted dynamically from the front or the back. They allow the elements to be accessed using random acess iterators. They are similar to vectors but are more efficient at insertion and deletion than vectors at the beginning and end of the container unlike vectors. Properties of deques that are efficient

		<span class=' d-block my-1'> </span>
		Data is stored strictly in a linear sequence. However, they are not guaranteed to be in be allocated contiguously space in memory. This means that an element cannot necessarily be accessed by using offsets of the pointer of another element, unlike arrays and vectors. Another implication of the non-contiguous allocation of memory is that deques can be more efficient at growing than vectors or arrays.

		<span class=' d-block my-1'> </span>
		Allows access to any element in the container and relatively fast insertion and deletion at the beginning and end of the container. This is because for each element in the deque, the element, forward pointer and backward pointer are stored in memory. New items can be added and removed at constant time from the ends of the container. But they are not as efficient when insertion or deletion occur at a random place along the container.
		
		<span class=' d-block my-3'> </span>
	</div>


	<div class='d-block fontLevel1 mt-1' id=''> Forward_list</div>
	<div class=' d-block fontLevel0'>

		Forward_list allow constant time insertion and deletion operations anywhere within the sequence. They are implemented as singly-linked list so they can store the elements they contain in different unrelated storage locations. To keep the order of the list, each element is associated with the next element on the list. These lists are more efficient at insertion and deletion of elements than deques, vectors and arrays.
		<span class=' d-block my-1'> </span>
		A property and disadvantage of forward_list is they lack direct access to the elements they contain, unlike deques, vectors and arrays. This means, if I want to access the 10th element on the array, I will need to iterate from the beginning till I get to the element I am looking for. Thus, it takes linear time to move from the beginning to a desired element in the container. Another feature and disadvantage of forward lists is they take up space in storing the information that links an element to the next element.
		<span class=' d-block my-1'> </span>
		Forward lists lack the information about its size. I cannot do aForwardList.size() to find the size of the forward_list. To compute the size of the list, we will need to use a distance algorithm with its begin and end.
		<span class=' d-block my-1'> </span>
		Data is stored in strict linear sequence.


		<!-- <ol>
			<li></li>
			<li></li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>


	<div class='d-block fontLevel1 mt-1' id=''> List</div>
	<div class=' d-block fontLevel0'>
		Lists are doubly-linked. This means that each element on the list is linked to the preceding element on the list and the next element on the list. This is different from forward_lists that are singly-linked meaning that each element is linked to only the following element on the list. This means that list can efficiently iterate in both directions. However, list use up more memory than forward_lists because for each element, two links (or pointers) need to be stored.
		This means that lists can be iterated forward and backwards because they are doubly-linked.
		<span class=' d-block my-1'> </span>
		Like forward_list, lists are more efficient at extracting and inserting elements anywhere in the array. However, lists are less efficient than forward_lists in inserting and erasing elements. <note class='text-danger'>Find out why lists are less efficient than forward_lists despite being doubly linked.</note>
		<span class=' d-block my-1'> </span>
		Like forward_list, list lack direct access to all elements on the container. To get to an element, I need to iterate either from a known position, usually the front or the back of the list.
		<span class=' d-block my-1'> </span>
		The size of a list, like a forward_list is dynamically allocated. There is an allocator object that dynamically handles storage.
		<span class=' d-block my-3'> </span>
	</div>



	<span class=' d-block my-5'> </span>
	<div class='d-block fontLevel2 my-1' id=''> Container Adaptors</div>
	In container adaptors, an underlying data-type is given additional member functions or stripped of some member functions to make the new container have some distinct characteristics. For example, the underlying container type for a container adaptor can be a vector, array or list. A key point to note about these container is they restrict access to the elements in the container.
	<div class='d-block fontLevel1 mt-1' id=''> Stack</div>
	<div class=' d-block fontLevel0'>
		Stacks are operated in a last-in first-out (LIFO) context. The underlying container type can be defined by the programmer. However, the default class is a deque.
		<!-- <ol>
			<li></li>
			<li></li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>


	<div class='d-block fontLevel1 mt-1' id=''> Queue</div>
	<div class=' d-block fontLevel0'>
		Stacks are operated in a First-in first-out (FIFO) context. The underlying container type can be defined by the programmer. However, the default class is a deque.

		<!-- <ol>
			<li></li>
			<li></li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>
	

	<div class='d-block fontLevel1 mt-1' id=''> Priority Queue</div>
	<div class=' d-block fontLevel0'>
		This container can be implemented like a heap. By default, if no container type is defined, then a vector is used as the underlying data-type for a priority_queue.
		This container provides constant time look-up for the largest element and logarithmic time look-up for all other elements in the container.
		

		<!-- <ol>
			<li></li>
			<li> <br>

			</li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>



	<span class=' d-block my-5'> </span>
	<div class='d-block fontLevel2 my-1' id=''> Associative Containers</div>
	<div class='d-block fontLevel1 mt-1' id=''>Set</div>
	<div class=' d-block fontLevel0'>
		Sets store data in a specific order. In a set, the value is also the key. So each item in the set must be found. The content of a set cannot be modified once placed in a set. This means that the elements of a set are always constant. Sets are slower than unordered_set to access individual elements by their keys this is because they are implemeted as binary search trees. Iterators are at least forward iterators.
		<note class='text-danger'>It appears that sets need to be constructed before use</note>
		<ol>
			<li>Sets are referenced by the values/keys and not by their specific location in the container</li>
			<li>They follow a strict order at all times</li>
			<li>The value of a set == the key of that value</li>
			<li>Since key==value, value must be unique. No 2 elements can have the same key</li>
			<li>Sets can dynamically allocate storage as needed</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>


	<div class='d-block fontLevel1 mt-1' id=''> Multiset</div>
	<div class=' d-block fontLevel0'>
		Multisets are similar to sets. However, in multisets, the values do not have the restriction of being unique. Similar to a set, a multiset elements are constant and cannot be modified once placed in a set. However, they can be inserted and/or removed. They are ordered and implemented as binary search trees as such the are less efficient than unordered_multisets. Iterators are at least forward iterators.

		<ol>
			<li>Multisets are referenced by their key, not by their location in the container</li>
			<li>They follow a strict order at all times</li>
			<li>Element value == element key</li>
			<li>Multiple elements values can have the same key</li>
			<li>They can be dynamically allocate their sizes</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>
	

	<div class='d-block fontLevel1 mt-1' id=''> Map</div>
	<div class=' d-block fontLevel0'>
		These store elements as a combination of keys and values and they follow a specific order. Map elements are identified by the keys and the keys need not be equivalent to the value. Internally, they are implemented as binary search trees.

		<ol>
			<li>They are referenced by their keys and not their location in the container</li>
			<li>The containers follow a strict order at all times</li>
			<li>Each element is an association of keys and value(s)</li>
			<li>The keys must be unique. No 2 elements can have the same key</li>
			<li>Size can be dynamically allocated</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>
	

	<div class='d-block fontLevel1 mt-1' id=''> Multimap</div>
	<div class=' d-block fontLevel0'>
		These store elements as a combination of keys and values and they follow a specific order. Multimap elements are identified by the keys and the keys need not be equivalent to the value. Multiple values can have equivalent keys. Internally, they are implemented as binary search trees.

		<ol>
			<li>They are referenced by their keys and not their location in the container</li>
			<li>The containers follow a strict order at all times</li>
			<li>Each element is an association of keys and value(s)</li>
			<li>The keys need not be unique. Elements can have equivalent key</li>
			<li>Size can be dynamically allocated</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>
	


	<span class=' d-block my-5'> </span>
	<div class='d-block fontLevel2 my-1' id=''> Unordered Associative Containers</div>
	<div class='d-block fontLevel1 mt-1' id=''>Unordered_set </div>
	<div class=' d-block fontLevel0'>
		This is essentially the same as a set. However, unlike a set, it is not ordered in any specific manner. Thus, it is more efficient in retrieving elements based on their value. Internally, elements are placed in the container in buckets based on a hash function. Thus, that allows for contant time retrieval of elements in the container. Iterators are at least forward iterators.

		<ol>
			<li>They are referenced by the values/keys and not by their specific location in the container</li>
			<li>They no specific order and are placed in buckets based on a hash table</li>
			<li>The value of a set == the key of that value</li>
			<li>Since key==value, value must be unique. No 2 elements can have the same key</li>
			<li>They can dynamically allocate storage as needed</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>


	<div class='d-block fontLevel1 mt-1' id=''>Unordered_multiset</div>
	<div class=' d-block fontLevel0'>
		These store elements in no specific order. The element key== element value so element key is constant, though it can be inserted and deleted.
		Elements with the same value are grouped together in a bucket and can be iterated. Iterators are at least forward iterators.

		<ol>
			<li>They are referenced by their key, not by their location in the container</li>
			<li>They follow no specific order and are placed into buckets based on a hash table. So they are more efficient for retrieving elements by value</li>
			<li>Element value == element key</li>
			<li>Multiple elements values can have the same key</li>
			<li>They can be dynamically allocate their sizes</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>
	

	<div class='d-block fontLevel1 mt-1' id=''> Unordered_map</div>
	<div class=' d-block fontLevel0'>
		These store elements as a combination of keys and values and they follow no specific order. Instead, elements are placed in buckets based on hash tables. Unordered_map elements are identified by the keys and the keys need not be equivalent to the value.

		<ol>
			<li>They are referenced by their keys and not their location in the container</li>
			<li>The containers are placed in the container based on a hash table allow for efficient retrieval of elements by value.</li>
			<li>Each element is an association of keys and value(s)</li>
			<li>The keys must be unique. No 2 elements can have the same key</li>
			<li>Size can be dynamically allocated</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>
		


	<div class='d-block fontLevel1 mt-1' id=''> Unordered_multimap</div>
	<div class=' d-block fontLevel0'>
		These store elements as a combination of keys and values and they follow a specific order. Unordered_multimap elements are identified by the keys and the keys need not be equivalent to the value. Multiple values can have equivalent keys. Internally, they are implemented as binary search trees.

		<ol>
			<li>They are referenced by their keys and not their location in the container</li>
			<li>The containers follow no particulaar order. Elements are placed according to a hash table</li>
			<li>Each element is an association of keys and value(s)</li>
			<li>The keys need not be unique. Elements can have equivalent key</li>
			<li>Size can be dynamically allocated</li>
		</ol>
		<span class=' d-block my-3'> </span>
	</div>


	<span class=' d-block my-5'> </span>
	<div class='d-block fontLevel2 my-1' id=''> User Implemented Containers</div>
	<div class='d-block fontLevel1 mt-1' id=''> Graph </div>
	<div class=' d-block fontLevel0'>
	Graphs can be visualised as networks that have edges and vertices. These edges can be one-directional or non-directed.
	Graphs can have costs associated with their edges. Examples of graph problems
	<li>Finding whether one can traverse all edges without traversing any twice (an Euler Path).</li>
	<li>The Travelling Salesman Problem - how to visit all the nodes at a minimal cost</li>
	<li>Finding the shortest (least cost) path between 2 vertices</li>
	<li>Finding the "minimal spanning tree" - finding a tree (with the least-cost edges) that includes all nodes</li>
	<span class=' d-block my-1'> </span>
	In a directed graph, (u,v) != (v,u). In an undirected graph, (u,v) == (v,u).
	<li>I define a graph as a vector that contains type vertex. Each index of the vector is the origin (src) node for that adjacent pair</li>
	<li>I define a vertex as an unordered_map of int and double where double signifies the destination node and the double is the weight of the edge. </li>
	<li>Edge definition is implicit in the definition of graphs and vertices. </li>


		<!-- <ol>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>



	<div class='d-block fontLevel1 mt-1' id=''> Tree </div>
	<div class=' d-block fontLevel0'>
		Trees are a special case of graphs that are not circular. That means trees generally have a defined root node and they have a defined end of the tree. So while transversing a tree, it is more difficult to enter an infinite loop compared with a tree. The characteristic of a tree is that each node branches into children. The most common form of trees are binary trees.
		<span class=' d-block my-1'> </span>
		In Binary trees, everything on the left of a node is greater than the node and everythin on the right of the node is greater than the node.
		In a balanced binary tree, the runtime for transversing the tree is log(N). However, most binary trees are not balanced. For a completely unbalanced binary tree, the runtime for transversing the tree is O(N) because the bianry tree then becomes a linked list.

		<!-- <ol>
			<li></li>
			<li> <br>

			</li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>



	<div class='d-block fontLevel1 mt-1' id=''> Tries </div>
	<div class=' d-block fontLevel0'>
		Tries are a clever way to store key, value pairs where the key is a string. In this datastructure, the root node is empty and has 26 child nodes each corrsponding to a letter in the alphabet.
		<span class=' d-block my-1'> </span>
		Each node (whether parent or child) has 26 child nodes it points to. So I implemented each node as a structure that can have a value, be a leaf, and has an array of 26 pointers to signify the child nodes of that node. 
		<span class=' d-block my-1'> </span>
		For ease, this data structure was implemented entirely with pointers. The nodes, and arrays were represented as pointers and appropriate allocations were made when needed.
		<span class=' d-block my-1'> </span>
		To make the word "peter", I will allocate the int('p')-'a' node connected to the root node. Then under the 'p' node, I will allocate the 'e' node and other such nodes.
		<!-- <ol>
			<li></li>
			<li> <br>

			</li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>


	<div class='d-block fontLevel1 mt-1' id=''> Heaps </div>
	<div class=' d-block fontLevel0'>
		Heaps are special binary trees that are always balanced. This means that no node has no children and each node is completely filled unless the last level.
		<span class=' d-block my-1'> </span>
		Heaps can either be min heap or max heap. In min heap, all parents are less than children. In max heap, all parents are greater than their children. Min heaps are used to sort in descending order and max heaps are used to sort in ascending order.
		<!-- <ol>
			<li></li>
			<li> <br>

			</li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>

	
			
	<div class='d-block fontLevel1 mt-1' id=''> </div>
	<div class=' d-block fontLevel0'>
		<!-- <ol>
			<li></li>
			<li> <br>

			</li>
			<li></li>
		</ol> -->
		<span class=' d-block my-3'> </span>
	</div>

	
			
		

	

</div>
</body>
</html>